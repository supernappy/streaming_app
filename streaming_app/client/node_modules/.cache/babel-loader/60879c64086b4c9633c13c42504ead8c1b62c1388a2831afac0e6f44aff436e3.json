{"ast":null,"code":"var _jsxFileName = \"/Users/walesolagbade/streaming_app/client/src/contexts/PlayerContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useRef, useEffect } from 'react';\nimport { Howl } from 'howler';\nimport { useSocket } from './SocketContext_enhanced';\nimport api from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PlayerContext = /*#__PURE__*/createContext();\nexport const usePlayer = () => {\n  _s();\n  const context = useContext(PlayerContext);\n  if (!context) {\n    throw new Error('usePlayer must be used within a PlayerProvider');\n  }\n  return context;\n};\n_s(usePlayer, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const PlayerProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    socket,\n    currentRoom\n  } = (useSocket === null || useSocket === void 0 ? void 0 : useSocket()) || {};\n  const [currentTrack, setCurrentTrack] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(0.8);\n  // Add recentlyPlayed state\n  const [recentlyPlayed, setRecentlyPlayed] = useState([]);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [queue, setQueue] = useState([]);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [shuffleMode, setShuffleMode] = useState(false);\n  const [repeatMode, setRepeatMode] = useState('off'); // 'off', 'all', 'one'\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const soundRef = useRef(null);\n  const intervalRef = useRef(null);\n  const testAudioRef = useRef(null);\n\n  // Removed auto-play on refresh. Player will only start when a track is clicked.\n\n  // Cleanup function to properly stop and dispose of audio resources\n  const cleanupAudio = () => {\n    if (soundRef.current) {\n      try {\n        soundRef.current.stop();\n        soundRef.current.unload();\n      } catch (error) {\n        console.warn('Error during Howl cleanup:', error);\n      }\n      soundRef.current = null;\n    }\n    if (testAudioRef.current) {\n      try {\n        testAudioRef.current.pause();\n        testAudioRef.current.src = '';\n        testAudioRef.current.load();\n      } catch (error) {\n        console.warn('Error during HTML5 audio cleanup:', error);\n      }\n      testAudioRef.current = null;\n    }\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  };\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanupAudio();\n    };\n  }, []);\n\n  // Test if track URL is accessible\n  const testTrackAccessibility = async url => {\n    try {\n      console.log('ðŸ” Testing track accessibility:', url);\n      const response = await fetch(url, {\n        method: 'HEAD',\n        mode: 'cors'\n      });\n      console.log('âœ… Track accessibility test result:', response.status, response.statusText);\n      return response.ok;\n    } catch (error) {\n      console.error('âŒ Track accessibility test failed:', error);\n      return false;\n    }\n  };\n\n  // Per-track timestamp guard to avoid immediate double counts on resume, but allow replays later\n  const lastIncrementAtRef = useRef({});\n\n  // Increment play count for a track (single fire per track start) using new endpoint\n  const incrementPlayCount = async track => {\n    if (!(track !== null && track !== void 0 && track.id)) return;\n    const id = track.id;\n    const now = Date.now();\n    const last = lastIncrementAtRef.current[id] || 0;\n    // Suppress duplicates within 2s (pause/resume), but allow replay after\n    if (now - last < 2000) return;\n    lastIncrementAtRef.current[id] = now;\n    try {\n      if (typeof window !== 'undefined') {\n        window.dispatchEvent(new CustomEvent('play-debug', {\n          detail: {\n            type: 'play-increment',\n            id,\n            ts: Date.now(),\n            roomId: currentRoom\n          }\n        }));\n      }\n      const payload = currentRoom ? {\n        roomId: currentRoom\n      } : {};\n      const res = await api.post(`/tracks/${id}/play`, payload);\n      if (res.data && res.data.track) {\n        const updatedTrack = res.data.track;\n        // Optimistically update currentTrack and queue copy\n        setCurrentTrack(prev => prev && prev.id === id ? {\n          ...prev,\n          play_count: updatedTrack.play_count\n        } : prev);\n        setQueue(prev => prev.map(t => t.id === id ? {\n          ...t,\n          play_count: updatedTrack.play_count\n        } : t));\n      }\n    } catch (err) {\n      console.warn('Failed to increment play count', err);\n    }\n  };\n\n  // Merge play_count updates received via socket into local state\n  useEffect(() => {\n    if (!socket) return;\n    const handler = ({\n      trackId,\n      play_count\n    }) => {\n      setCurrentTrack(prev => prev && prev.id === trackId ? {\n        ...prev,\n        play_count\n      } : prev);\n      setQueue(prev => prev.map(t => t.id === trackId ? {\n        ...t,\n        play_count\n      } : t));\n    };\n    socket.on('track:play-count-updated', handler);\n    return () => {\n      socket.off('track:play-count-updated', handler);\n    };\n  }, [socket]);\n  const playTrack = async (track, trackListArg) => {\n    console.log('=== PLAYER DEBUG ===');\n    console.log('Attempting to play track:', track);\n    console.log('Track file_url:', track.file_url);\n    console.log('Track hls_url:', track.hls_url);\n\n    // Clean up any existing audio resources first\n    cleanupAudio();\n    setError(null); // Clear any previous errors\n\n    setIsLoading(true);\n    let fullTrack = track;\n    // If lyrics is missing, fetch full track details\n    if (!track.lyrics) {\n      try {\n        const res = await api.get(`/tracks/${track.id}`);\n        if (res.data && res.data.track) {\n          fullTrack = {\n            ...track,\n            ...res.data.track\n          };\n        }\n      } catch (err) {\n        console.warn('Failed to fetch full track details for lyrics:', err);\n      }\n    }\n    setCurrentTrack(fullTrack);\n    // Use provided trackListArg as queue if available, else use current queue\n    const queueToUse = Array.isArray(trackListArg) && trackListArg.length > 0 ? trackListArg : queue;\n    setQueue(queueToUse);\n    setCurrentIndex(queueToUse.findIndex(t => t.id === track.id));\n    const audioUrl = fullTrack.hls_url || fullTrack.file_url;\n    console.log('Using audio URL:', audioUrl);\n\n    // Validate URL\n    if (!audioUrl) {\n      setError('No audio URL available for this track');\n      setIsLoading(false);\n      return;\n    }\n\n    // Test track accessibility before attempting to play\n    const isAccessible = await testTrackAccessibility(audioUrl);\n    if (!isAccessible) {\n      console.error('âŒ Track is not accessible');\n      setError('Cannot access audio file. The track may be missing or the server is unavailable.');\n      setIsLoading(false);\n      return;\n    }\n    setIsLoading(false);\n    setIsPlaying(true);\n    setCurrentTime(0);\n    setDuration(fullTrack.duration || 0);\n  };\n  const handleTrackEnd = () => {\n    try {\n      if (repeatMode === 'one') {\n        // Replay current track\n        if (soundRef.current && soundRef.current.state() === 'loaded') {\n          soundRef.current.seek(0);\n          soundRef.current.play();\n        }\n      } else if (repeatMode === 'all' || queue.length > currentIndex + 1) {\n        playNext();\n      }\n    } catch (error) {\n      console.error('âŒ Error in handleTrackEnd:', error);\n      setIsPlaying(false);\n    }\n  };\n  const startTimeTracking = () => {\n    intervalRef.current = setInterval(() => {\n      if (soundRef.current && soundRef.current.playing()) {\n        setCurrentTime(soundRef.current.seek());\n      }\n    }, 1000);\n  };\n  const togglePlayPause = () => {\n    if (soundRef.current && soundRef.current.state() === 'loaded') {\n      try {\n        if (isPlaying) {\n          soundRef.current.pause();\n        } else {\n          // Check if the sound is still valid before playing\n          if (soundRef.current._src) {\n            const playPromise = soundRef.current.play();\n            if (playPromise !== undefined) {\n              // Handle the promise if returned\n              console.log('Play initiated successfully');\n            }\n          }\n        }\n      } catch (error) {\n        console.error('âŒ Error in togglePlayPause:', error);\n        setIsPlaying(false);\n        setIsLoading(false);\n      }\n    }\n  };\n  const seek = time => {\n    if (soundRef.current) {\n      soundRef.current.seek(time);\n      setCurrentTime(time);\n    }\n  };\n  const changeVolume = newVolume => {\n    setVolume(newVolume);\n    if (soundRef.current) {\n      soundRef.current.volume(newVolume);\n    }\n  };\n  const playNext = () => {\n    if (queue.length > 0) {\n      let nextIndex;\n      if (shuffleMode) {\n        // Random next track\n        nextIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex < queue.length - 1) {\n        nextIndex = currentIndex + 1;\n      } else if (repeatMode === 'all') {\n        nextIndex = 0; // Loop back to start\n      } else {\n        return; // No next track\n      }\n      const nextTrack = queue[nextIndex];\n      playTrack(nextTrack, queue);\n    }\n  };\n  const playPrevious = () => {\n    if (queue.length > 0) {\n      let prevIndex;\n      if (shuffleMode) {\n        // Random previous track\n        prevIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex > 0) {\n        prevIndex = currentIndex - 1;\n      } else if (repeatMode === 'all') {\n        prevIndex = queue.length - 1; // Loop to end\n      } else {\n        return; // No previous track\n      }\n      const prevTrack = queue[prevIndex];\n      playTrack(prevTrack, queue);\n    }\n  };\n  const toggleShuffle = () => {\n    setShuffleMode(!shuffleMode);\n  };\n  const setRepeat = mode => {\n    setRepeatMode(mode);\n  };\n  const addToQueue = track => {\n    setQueue(prev => [...prev, track]);\n  };\n  const removeFromQueue = trackId => {\n    setQueue(prev => prev.filter(track => track.id !== trackId));\n  };\n  const clearQueue = () => {\n    setQueue([]);\n    setCurrentIndex(0);\n  };\n  const stop = () => {\n    cleanupAudio();\n    setCurrentTrack(null);\n    setIsPlaying(false);\n    setCurrentTime(0);\n    setIsLoading(false);\n  };\n  const value = {\n    currentTrack,\n    isPlaying,\n    volume,\n    currentTime,\n    duration,\n    queue,\n    currentIndex,\n    shuffleMode,\n    repeatMode,\n    isLoading,\n    error,\n    playTrack,\n    incrementPlayCount,\n    // Expose incrementPlayCount to consumers\n    togglePlayPause,\n    stop,\n    seek,\n    changeVolume,\n    playNext,\n    playPrevious,\n    addToQueue,\n    removeFromQueue,\n    clearQueue,\n    toggleShuffle,\n    setRepeat,\n    recentlyPlayed,\n    setRecentlyPlayed\n  };\n  return /*#__PURE__*/_jsxDEV(PlayerContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 347,\n    columnNumber: 5\n  }, this);\n};\n_s2(PlayerProvider, \"3wswIW5iEyzMM7QhIjUSnmRhTyU=\");\n_c = PlayerProvider;\nvar _c;\n$RefreshReg$(_c, \"PlayerProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useRef","useEffect","Howl","useSocket","api","jsxDEV","_jsxDEV","PlayerContext","usePlayer","_s","context","Error","PlayerProvider","children","_s2","socket","currentRoom","currentTrack","setCurrentTrack","isPlaying","setIsPlaying","volume","setVolume","recentlyPlayed","setRecentlyPlayed","currentTime","setCurrentTime","duration","setDuration","queue","setQueue","currentIndex","setCurrentIndex","shuffleMode","setShuffleMode","repeatMode","setRepeatMode","isLoading","setIsLoading","error","setError","soundRef","intervalRef","testAudioRef","cleanupAudio","current","stop","unload","console","warn","pause","src","load","clearInterval","testTrackAccessibility","url","log","response","fetch","method","mode","status","statusText","ok","lastIncrementAtRef","incrementPlayCount","track","id","now","Date","last","window","dispatchEvent","CustomEvent","detail","type","ts","roomId","payload","res","post","data","updatedTrack","prev","play_count","map","t","err","handler","trackId","on","off","playTrack","trackListArg","file_url","hls_url","fullTrack","lyrics","get","queueToUse","Array","isArray","length","findIndex","audioUrl","isAccessible","handleTrackEnd","state","seek","play","playNext","startTimeTracking","setInterval","playing","togglePlayPause","_src","playPromise","undefined","time","changeVolume","newVolume","nextIndex","Math","floor","random","nextTrack","playPrevious","prevIndex","prevTrack","toggleShuffle","setRepeat","addToQueue","removeFromQueue","filter","clearQueue","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/walesolagbade/streaming_app/client/src/contexts/PlayerContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useRef, useEffect } from 'react';\nimport { Howl } from 'howler';\nimport { useSocket } from './SocketContext_enhanced';\nimport api from '../services/api';\n\nconst PlayerContext = createContext();\n\nexport const usePlayer = () => {\n  const context = useContext(PlayerContext);\n  if (!context) {\n    throw new Error('usePlayer must be used within a PlayerProvider');\n  }\n  return context;\n};\n\nexport const PlayerProvider = ({ children }) => {\n  const { socket, currentRoom } = useSocket?.() || {};\n  const [currentTrack, setCurrentTrack] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(0.8);\n  // Add recentlyPlayed state\n  const [recentlyPlayed, setRecentlyPlayed] = useState([]);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [queue, setQueue] = useState([]);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [shuffleMode, setShuffleMode] = useState(false);\n  const [repeatMode, setRepeatMode] = useState('off'); // 'off', 'all', 'one'\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const soundRef = useRef(null);\n  const intervalRef = useRef(null);\n  const testAudioRef = useRef(null);\n\n  // Removed auto-play on refresh. Player will only start when a track is clicked.\n\n  // Cleanup function to properly stop and dispose of audio resources\n  const cleanupAudio = () => {\n    if (soundRef.current) {\n      try {\n        soundRef.current.stop();\n        soundRef.current.unload();\n      } catch (error) {\n        console.warn('Error during Howl cleanup:', error);\n      }\n      soundRef.current = null;\n    }\n    \n    if (testAudioRef.current) {\n      try {\n        testAudioRef.current.pause();\n        testAudioRef.current.src = '';\n        testAudioRef.current.load();\n      } catch (error) {\n        console.warn('Error during HTML5 audio cleanup:', error);\n      }\n      testAudioRef.current = null;\n    }\n    \n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  };\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanupAudio();\n    };\n  }, []);\n\n    // Test if track URL is accessible\n  const testTrackAccessibility = async (url) => {\n    try {\n      console.log('ðŸ” Testing track accessibility:', url);\n      const response = await fetch(url, { \n        method: 'HEAD',\n        mode: 'cors'\n      });\n      console.log('âœ… Track accessibility test result:', response.status, response.statusText);\n      return response.ok;\n    } catch (error) {\n      console.error('âŒ Track accessibility test failed:', error);\n      return false;\n    }\n  };\n\n  // Per-track timestamp guard to avoid immediate double counts on resume, but allow replays later\n  const lastIncrementAtRef = useRef({});\n\n  // Increment play count for a track (single fire per track start) using new endpoint\n  const incrementPlayCount = async (track) => {\n    if (!track?.id) return;\n    const id = track.id;\n    const now = Date.now();\n    const last = lastIncrementAtRef.current[id] || 0;\n    // Suppress duplicates within 2s (pause/resume), but allow replay after\n    if (now - last < 2000) return;\n    lastIncrementAtRef.current[id] = now;\n    try {\n      if (typeof window !== 'undefined') {\n        window.dispatchEvent(new CustomEvent('play-debug', { detail: { type: 'play-increment', id, ts: Date.now(), roomId: currentRoom } }));\n      }\n      const payload = currentRoom ? { roomId: currentRoom } : {};\n      const res = await api.post(`/tracks/${id}/play`, payload);\n      if (res.data && res.data.track) {\n        const updatedTrack = res.data.track;\n        // Optimistically update currentTrack and queue copy\n        setCurrentTrack(prev => prev && prev.id === id ? { ...prev, play_count: updatedTrack.play_count } : prev);\n        setQueue(prev => prev.map(t => t.id === id ? { ...t, play_count: updatedTrack.play_count } : t));\n      }\n    } catch (err) {\n      console.warn('Failed to increment play count', err);\n    }\n  };\n\n  // Merge play_count updates received via socket into local state\n  useEffect(() => {\n    if (!socket) return;\n    const handler = ({ trackId, play_count }) => {\n      setCurrentTrack(prev => (prev && prev.id === trackId) ? { ...prev, play_count } : prev);\n      setQueue(prev => prev.map(t => t.id === trackId ? { ...t, play_count } : t));\n    };\n    socket.on('track:play-count-updated', handler);\n    return () => {\n      socket.off('track:play-count-updated', handler);\n    };\n  }, [socket]);\n\n  const playTrack = async (track, trackListArg) => {\n    console.log('=== PLAYER DEBUG ===');\n    console.log('Attempting to play track:', track);\n    console.log('Track file_url:', track.file_url);\n    console.log('Track hls_url:', track.hls_url);\n    \n    // Clean up any existing audio resources first\n    cleanupAudio();\n    setError(null); // Clear any previous errors\n\n    setIsLoading(true);\n    let fullTrack = track;\n    // If lyrics is missing, fetch full track details\n    if (!track.lyrics) {\n      try {\n        const res = await api.get(`/tracks/${track.id}`);\n        if (res.data && res.data.track) {\n          fullTrack = { ...track, ...res.data.track };\n        }\n      } catch (err) {\n        console.warn('Failed to fetch full track details for lyrics:', err);\n      }\n    }\n    setCurrentTrack(fullTrack);\n    // Use provided trackListArg as queue if available, else use current queue\n    const queueToUse = Array.isArray(trackListArg) && trackListArg.length > 0 ? trackListArg : queue;\n    setQueue(queueToUse);\n    setCurrentIndex(queueToUse.findIndex(t => t.id === track.id));\n\n    const audioUrl = fullTrack.hls_url || fullTrack.file_url;\n    console.log('Using audio URL:', audioUrl);\n\n    // Validate URL\n    if (!audioUrl) {\n      setError('No audio URL available for this track');\n      setIsLoading(false);\n      return;\n    }\n\n    // Test track accessibility before attempting to play\n    const isAccessible = await testTrackAccessibility(audioUrl);\n    if (!isAccessible) {\n      console.error('âŒ Track is not accessible');\n      setError('Cannot access audio file. The track may be missing or the server is unavailable.');\n      setIsLoading(false);\n      return;\n    }\n\n    setIsLoading(false);\n    setIsPlaying(true);\n    setCurrentTime(0);\n    setDuration(fullTrack.duration || 0);\n  };\n\n  const handleTrackEnd = () => {\n    try {\n      if (repeatMode === 'one') {\n        // Replay current track\n        if (soundRef.current && soundRef.current.state() === 'loaded') {\n          soundRef.current.seek(0);\n          soundRef.current.play();\n        }\n      } else if (repeatMode === 'all' || queue.length > currentIndex + 1) {\n        playNext();\n      }\n    } catch (error) {\n      console.error('âŒ Error in handleTrackEnd:', error);\n      setIsPlaying(false);\n    }\n  };\n\n  const startTimeTracking = () => {\n    intervalRef.current = setInterval(() => {\n      if (soundRef.current && soundRef.current.playing()) {\n        setCurrentTime(soundRef.current.seek());\n      }\n    }, 1000);\n  };\n\n  const togglePlayPause = () => {\n    if (soundRef.current && soundRef.current.state() === 'loaded') {\n      try {\n        if (isPlaying) {\n          soundRef.current.pause();\n        } else {\n          // Check if the sound is still valid before playing\n          if (soundRef.current._src) {\n            const playPromise = soundRef.current.play();\n            if (playPromise !== undefined) {\n              // Handle the promise if returned\n              console.log('Play initiated successfully');\n            }\n          }\n        }\n      } catch (error) {\n        console.error('âŒ Error in togglePlayPause:', error);\n        setIsPlaying(false);\n        setIsLoading(false);\n      }\n    }\n  };\n\n  const seek = (time) => {\n    if (soundRef.current) {\n      soundRef.current.seek(time);\n      setCurrentTime(time);\n    }\n  };\n\n  const changeVolume = (newVolume) => {\n    setVolume(newVolume);\n    if (soundRef.current) {\n      soundRef.current.volume(newVolume);\n    }\n  };\n\n  const playNext = () => {\n    if (queue.length > 0) {\n      let nextIndex;\n      \n      if (shuffleMode) {\n        // Random next track\n        nextIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex < queue.length - 1) {\n        nextIndex = currentIndex + 1;\n      } else if (repeatMode === 'all') {\n        nextIndex = 0; // Loop back to start\n      } else {\n        return; // No next track\n      }\n      \n      const nextTrack = queue[nextIndex];\n      playTrack(nextTrack, queue);\n    }\n  };\n\n  const playPrevious = () => {\n    if (queue.length > 0) {\n      let prevIndex;\n      \n      if (shuffleMode) {\n        // Random previous track\n        prevIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex > 0) {\n        prevIndex = currentIndex - 1;\n      } else if (repeatMode === 'all') {\n        prevIndex = queue.length - 1; // Loop to end\n      } else {\n        return; // No previous track\n      }\n      \n      const prevTrack = queue[prevIndex];\n      playTrack(prevTrack, queue);\n    }\n  };\n\n  const toggleShuffle = () => {\n    setShuffleMode(!shuffleMode);\n  };\n\n  const setRepeat = (mode) => {\n    setRepeatMode(mode);\n  };\n\n  const addToQueue = (track) => {\n    setQueue(prev => [...prev, track]);\n  };\n\n  const removeFromQueue = (trackId) => {\n    setQueue(prev => prev.filter(track => track.id !== trackId));\n  };\n\n  const clearQueue = () => {\n    setQueue([]);\n    setCurrentIndex(0);\n  };\n\n  const stop = () => {\n    cleanupAudio();\n    setCurrentTrack(null);\n    setIsPlaying(false);\n    setCurrentTime(0);\n    setIsLoading(false);\n  };\n\n  const value = {\n    currentTrack,\n    isPlaying,\n    volume,\n    currentTime,\n    duration,\n    queue,\n    currentIndex,\n    shuffleMode,\n    repeatMode,\n    isLoading,\n    error,\n    playTrack,\n    incrementPlayCount, // Expose incrementPlayCount to consumers\n    togglePlayPause,\n    stop,\n    seek,\n    changeVolume,\n    playNext,\n    playPrevious,\n    addToQueue,\n    removeFromQueue,\n    clearQueue,\n    toggleShuffle,\n    setRepeat,\n    recentlyPlayed,\n    setRecentlyPlayed\n  };\n\n  return (\n    <PlayerContext.Provider value={value}>\n      {children}\n    </PlayerContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}