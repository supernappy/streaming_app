{"ast":null,"code":"var _jsxFileName = \"/Users/walesolagbade/streaming_app/client/src/contexts/PlayerContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useRef, useEffect } from 'react';\nimport { Howl } from 'howler';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PlayerContext = /*#__PURE__*/createContext();\nexport const usePlayer = () => {\n  _s();\n  const context = useContext(PlayerContext);\n  if (!context) {\n    throw new Error('usePlayer must be used within a PlayerProvider');\n  }\n  return context;\n};\n_s(usePlayer, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const PlayerProvider = ({\n  children\n}) => {\n  _s2();\n  const [currentTrack, setCurrentTrack] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(0.8);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [queue, setQueue] = useState([]);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [shuffleMode, setShuffleMode] = useState(false);\n  const [repeatMode, setRepeatMode] = useState('off'); // 'off', 'all', 'one'\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const soundRef = useRef(null);\n  const intervalRef = useRef(null);\n  const testAudioRef = useRef(null);\n\n  // Cleanup function to properly stop and dispose of audio resources\n  const cleanupAudio = () => {\n    if (soundRef.current) {\n      try {\n        soundRef.current.stop();\n        soundRef.current.unload();\n      } catch (error) {\n        console.warn('Error during Howl cleanup:', error);\n      }\n      soundRef.current = null;\n    }\n    if (testAudioRef.current) {\n      try {\n        testAudioRef.current.pause();\n        testAudioRef.current.src = '';\n        testAudioRef.current.load();\n      } catch (error) {\n        console.warn('Error during HTML5 audio cleanup:', error);\n      }\n      testAudioRef.current = null;\n    }\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  };\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanupAudio();\n    };\n  }, []);\n\n  // Test if track URL is accessible\n  const testTrackAccessibility = async url => {\n    try {\n      console.log('ðŸ” Testing track accessibility:', url);\n      const response = await fetch(url, {\n        method: 'HEAD',\n        mode: 'cors'\n      });\n      console.log('âœ… Track accessibility test result:', response.status, response.statusText);\n      return response.ok;\n    } catch (error) {\n      console.error('âŒ Track accessibility test failed:', error);\n      return false;\n    }\n  };\n\n  // Keep a session-level set of tracks already incremented to avoid double counting on resume\n  const incrementedRef = useRef(new Set());\n  const lastIncrementTrackIdRef = useRef(null);\n\n  // Increment play count for a track (single fire per track start) using new endpoint\n  const incrementPlayCount = async track => {\n    if (!(track !== null && track !== void 0 && track.id)) return;\n    const id = track.id;\n    // Avoid duplicate increments if already incremented during this play session\n    if (lastIncrementTrackIdRef.current === id) return;\n    lastIncrementTrackIdRef.current = id;\n    try {\n      const res = await fetch(`/api/tracks/${id}/play`, {\n        method: 'POST'\n      });\n      if (res.ok) {\n        const data = await res.json();\n        const updatedTrack = data.track;\n        // Optimistically update currentTrack and queue copy\n        setCurrentTrack(prev => prev && prev.id === id ? {\n          ...prev,\n          play_count: updatedTrack.play_count\n        } : prev);\n        setQueue(prev => prev.map(t => t.id === id ? {\n          ...t,\n          play_count: updatedTrack.play_count\n        } : t));\n      }\n    } catch (err) {\n      console.warn('Failed to increment play count', err);\n    }\n  };\n  const playTrack = async (track, trackListArg) => {\n    console.log('=== PLAYER DEBUG ===');\n    console.log('Attempting to play track:', track);\n    console.log('Track file_url:', track.file_url);\n    console.log('Track hls_url:', track.hls_url);\n\n    // Clean up any existing audio resources first\n    cleanupAudio();\n    setError(null); // Clear any previous errors\n\n    setIsLoading(true);\n    setCurrentTrack(track);\n    // Use provided trackListArg as queue if available, else use current queue\n    const queueToUse = Array.isArray(trackListArg) && trackListArg.length > 0 ? trackListArg : queue;\n    setQueue(queueToUse);\n    setCurrentIndex(queueToUse.findIndex(t => t.id === track.id));\n    const audioUrl = track.hls_url || track.file_url;\n    console.log('Using audio URL:', audioUrl);\n\n    // Validate URL\n    if (!audioUrl) {\n      setError('No audio URL available for this track');\n      setIsLoading(false);\n      return;\n    }\n\n    // Test track accessibility before attempting to play\n    const isAccessible = await testTrackAccessibility(audioUrl);\n    if (!isAccessible) {\n      console.error('âŒ Track is not accessible');\n      setError('Cannot access audio file. The track may be missing or the server is unavailable.');\n      setIsLoading(false);\n      return;\n    }\n    console.log('âœ… Track is accessible, proceeding with audio setup...');\n\n    // Test direct HTML5 audio first for debugging\n    testAudioRef.current = new Audio();\n    testAudioRef.current.crossOrigin = 'anonymous';\n    testAudioRef.current.preload = 'metadata';\n    testAudioRef.current.addEventListener('canplay', () => {\n      console.log('âœ… HTML5 Audio can play this file');\n    });\n    testAudioRef.current.addEventListener('loadedmetadata', () => {\n      console.log('âœ… HTML5 Audio metadata loaded, duration:', testAudioRef.current.duration);\n    });\n    testAudioRef.current.addEventListener('error', e => {\n      var _testAudioRef$current, _testAudioRef$current2, _testAudioRef$current3, _testAudioRef$current4, _testAudioRef$current5, _testAudioRef$current6;\n      console.error('âŒ HTML5 Audio error:', e);\n      console.error('Audio error code:', (_testAudioRef$current = testAudioRef.current) === null || _testAudioRef$current === void 0 ? void 0 : (_testAudioRef$current2 = _testAudioRef$current.error) === null || _testAudioRef$current2 === void 0 ? void 0 : _testAudioRef$current2.code);\n      console.error('Audio error message:', (_testAudioRef$current3 = testAudioRef.current) === null || _testAudioRef$current3 === void 0 ? void 0 : (_testAudioRef$current4 = _testAudioRef$current3.error) === null || _testAudioRef$current4 === void 0 ? void 0 : _testAudioRef$current4.message);\n\n      // Error codes: 1=ABORTED, 2=NETWORK, 3=DECODE, 4=SRC_NOT_SUPPORTED\n      const errorMessages = {\n        1: 'Audio loading was aborted',\n        2: 'Network error while loading audio',\n        3: 'Audio decoding failed',\n        4: 'Audio format not supported'\n      };\n      const errorCode = (_testAudioRef$current5 = testAudioRef.current) === null || _testAudioRef$current5 === void 0 ? void 0 : (_testAudioRef$current6 = _testAudioRef$current5.error) === null || _testAudioRef$current6 === void 0 ? void 0 : _testAudioRef$current6.code;\n      const errorMsg = errorMessages[errorCode] || 'Unknown audio error';\n      console.error('Detailed error:', errorMsg);\n    });\n\n    // Set source and load\n    testAudioRef.current.src = audioUrl;\n    testAudioRef.current.load();\n\n    // Create new Howl instance with better error handling\n    soundRef.current = new Howl({\n      src: [audioUrl],\n      html5: true,\n      // Use HTML5 Audio for better compatibility\n      format: ['mp3', 'wav', 'mpeg'],\n      // Support multiple formats\n      volume: volume,\n      preload: true,\n      cors: true,\n      // Enable CORS\n      onload: () => {\n        console.log('âœ… Howler: Audio loaded successfully');\n        console.log('Duration:', soundRef.current.duration());\n        setDuration(soundRef.current.duration());\n        setIsLoading(false);\n        setError(null);\n      },\n      onplay: () => {\n        console.log('âœ… Howler: Audio started playing');\n        setIsPlaying(true);\n        setIsLoading(false);\n        setError(null);\n        startTimeTracking();\n        if (track && track.id) {\n          incrementPlayCount(track);\n        }\n      },\n      onpause: () => {\n        console.log('â¸ï¸ Howler: Audio paused');\n        setIsPlaying(false);\n        clearInterval(intervalRef.current);\n      },\n      onend: () => {\n        console.log('ðŸ”š Howler: Audio ended');\n        setIsPlaying(false);\n        setCurrentTime(0);\n        clearInterval(intervalRef.current);\n        handleTrackEnd();\n      },\n      onloaderror: (id, error) => {\n        console.error('âŒ Howler: Audio load error:', error);\n        console.error('âŒ Howler: Error ID:', id);\n        console.error('âŒ Howler: Full error object:', error);\n\n        // More specific error messages\n        let errorMsg = 'Failed to load audio file.';\n        if (typeof error === 'string' && error.includes('404')) {\n          errorMsg = 'Audio file not found (404). The track may have been moved or deleted.';\n        } else if (typeof error === 'string' && error.includes('CORS')) {\n          errorMsg = 'Cross-origin request blocked. Please contact support.';\n        } else if (typeof error === 'string' && error.includes('network')) {\n          errorMsg = 'Network error. Please check your connection and try again.';\n        }\n        setError(errorMsg);\n        setIsLoading(false);\n        setIsPlaying(false);\n      },\n      onplayerror: (id, error) => {\n        console.error('âŒ Howler: Audio play error:', error);\n        console.error('âŒ Howler: Error ID:', id);\n        let errorMsg = 'Failed to play audio.';\n        if (typeof error === 'string' && error.includes('NotAllowedError')) {\n          errorMsg = 'Playback blocked by browser. Please click play again to allow audio.';\n        } else if (typeof error === 'string' && error.includes('decode')) {\n          errorMsg = 'Audio file is corrupted or in an unsupported format.';\n        }\n        setError(errorMsg);\n        setIsLoading(false);\n        setIsPlaying(false);\n      },\n      onerror: error => {\n        console.error('âŒ Howler: General audio error:', error);\n        setError('An audio error occurred. Please try refreshing the page.');\n        setIsLoading(false);\n        setIsPlaying(false);\n      }\n    });\n    console.log('ðŸ”„ Howler instance created, attempting to play...');\n    try {\n      // Add a small delay to ensure the audio is properly loaded\n      setTimeout(() => {\n        if (soundRef.current && soundRef.current.state() === 'loaded') {\n          const playResult = soundRef.current.play();\n          console.log('Play result:', playResult);\n        }\n      }, 100);\n    } catch (error) {\n      console.error('âŒ Play attempt failed:', error);\n      setError('Failed to start playback. Please try again.');\n      setIsLoading(false);\n      setIsPlaying(false);\n    }\n  };\n  const handleTrackEnd = () => {\n    try {\n      if (repeatMode === 'one') {\n        // Replay current track\n        if (soundRef.current && soundRef.current.state() === 'loaded') {\n          soundRef.current.seek(0);\n          soundRef.current.play();\n        }\n      } else if (repeatMode === 'all' || queue.length > currentIndex + 1) {\n        playNext();\n      }\n    } catch (error) {\n      console.error('âŒ Error in handleTrackEnd:', error);\n      setIsPlaying(false);\n    }\n  };\n  const startTimeTracking = () => {\n    intervalRef.current = setInterval(() => {\n      if (soundRef.current && soundRef.current.playing()) {\n        setCurrentTime(soundRef.current.seek());\n      }\n    }, 1000);\n  };\n  const togglePlayPause = () => {\n    if (soundRef.current && soundRef.current.state() === 'loaded') {\n      try {\n        if (isPlaying) {\n          soundRef.current.pause();\n        } else {\n          // Check if the sound is still valid before playing\n          if (soundRef.current._src) {\n            const playPromise = soundRef.current.play();\n            if (playPromise !== undefined) {\n              // Handle the promise if returned\n              console.log('Play initiated successfully');\n            }\n          }\n        }\n      } catch (error) {\n        console.error('âŒ Error in togglePlayPause:', error);\n        setIsPlaying(false);\n        setIsLoading(false);\n      }\n    }\n  };\n  const seek = time => {\n    if (soundRef.current) {\n      soundRef.current.seek(time);\n      setCurrentTime(time);\n    }\n  };\n  const changeVolume = newVolume => {\n    setVolume(newVolume);\n    if (soundRef.current) {\n      soundRef.current.volume(newVolume);\n    }\n  };\n  const playNext = () => {\n    if (queue.length > 0) {\n      let nextIndex;\n      if (shuffleMode) {\n        // Random next track\n        nextIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex < queue.length - 1) {\n        nextIndex = currentIndex + 1;\n      } else if (repeatMode === 'all') {\n        nextIndex = 0; // Loop back to start\n      } else {\n        return; // No next track\n      }\n      const nextTrack = queue[nextIndex];\n      playTrack(nextTrack, queue);\n    }\n  };\n  const playPrevious = () => {\n    if (queue.length > 0) {\n      let prevIndex;\n      if (shuffleMode) {\n        // Random previous track\n        prevIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex > 0) {\n        prevIndex = currentIndex - 1;\n      } else if (repeatMode === 'all') {\n        prevIndex = queue.length - 1; // Loop to end\n      } else {\n        return; // No previous track\n      }\n      const prevTrack = queue[prevIndex];\n      playTrack(prevTrack, queue);\n    }\n  };\n  const toggleShuffle = () => {\n    setShuffleMode(!shuffleMode);\n  };\n  const setRepeat = mode => {\n    setRepeatMode(mode);\n  };\n  const addToQueue = track => {\n    setQueue(prev => [...prev, track]);\n  };\n  const removeFromQueue = trackId => {\n    setQueue(prev => prev.filter(track => track.id !== trackId));\n  };\n  const clearQueue = () => {\n    setQueue([]);\n    setCurrentIndex(0);\n  };\n  const stop = () => {\n    cleanupAudio();\n    setCurrentTrack(null);\n    setIsPlaying(false);\n    setCurrentTime(0);\n    setIsLoading(false);\n  };\n  const value = {\n    currentTrack,\n    isPlaying,\n    volume,\n    currentTime,\n    duration,\n    queue,\n    currentIndex,\n    shuffleMode,\n    repeatMode,\n    isLoading,\n    error,\n    playTrack,\n    togglePlayPause,\n    stop,\n    seek,\n    changeVolume,\n    playNext,\n    playPrevious,\n    addToQueue,\n    removeFromQueue,\n    clearQueue,\n    toggleShuffle,\n    setRepeat\n  };\n  return /*#__PURE__*/_jsxDEV(PlayerContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 435,\n    columnNumber: 5\n  }, this);\n};\n_s2(PlayerProvider, \"0uJ6Z3L2Vmjx0ISCo4dQ2i6RDRk=\");\n_c = PlayerProvider;\nvar _c;\n$RefreshReg$(_c, \"PlayerProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useRef","useEffect","Howl","jsxDEV","_jsxDEV","PlayerContext","usePlayer","_s","context","Error","PlayerProvider","children","_s2","currentTrack","setCurrentTrack","isPlaying","setIsPlaying","volume","setVolume","currentTime","setCurrentTime","duration","setDuration","queue","setQueue","currentIndex","setCurrentIndex","shuffleMode","setShuffleMode","repeatMode","setRepeatMode","isLoading","setIsLoading","error","setError","soundRef","intervalRef","testAudioRef","cleanupAudio","current","stop","unload","console","warn","pause","src","load","clearInterval","testTrackAccessibility","url","log","response","fetch","method","mode","status","statusText","ok","incrementedRef","Set","lastIncrementTrackIdRef","incrementPlayCount","track","id","res","data","json","updatedTrack","prev","play_count","map","t","err","playTrack","trackListArg","file_url","hls_url","queueToUse","Array","isArray","length","findIndex","audioUrl","isAccessible","Audio","crossOrigin","preload","addEventListener","e","_testAudioRef$current","_testAudioRef$current2","_testAudioRef$current3","_testAudioRef$current4","_testAudioRef$current5","_testAudioRef$current6","code","message","errorMessages","errorCode","errorMsg","html5","format","cors","onload","onplay","startTimeTracking","onpause","onend","handleTrackEnd","onloaderror","includes","onplayerror","onerror","setTimeout","state","playResult","play","seek","playNext","setInterval","playing","togglePlayPause","_src","playPromise","undefined","time","changeVolume","newVolume","nextIndex","Math","floor","random","nextTrack","playPrevious","prevIndex","prevTrack","toggleShuffle","setRepeat","addToQueue","removeFromQueue","trackId","filter","clearQueue","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/walesolagbade/streaming_app/client/src/contexts/PlayerContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useRef, useEffect } from 'react';\nimport { Howl } from 'howler';\n\nconst PlayerContext = createContext();\n\nexport const usePlayer = () => {\n  const context = useContext(PlayerContext);\n  if (!context) {\n    throw new Error('usePlayer must be used within a PlayerProvider');\n  }\n  return context;\n};\n\nexport const PlayerProvider = ({ children }) => {\n  const [currentTrack, setCurrentTrack] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(0.8);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [queue, setQueue] = useState([]);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [shuffleMode, setShuffleMode] = useState(false);\n  const [repeatMode, setRepeatMode] = useState('off'); // 'off', 'all', 'one'\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const soundRef = useRef(null);\n  const intervalRef = useRef(null);\n  const testAudioRef = useRef(null);\n\n  // Cleanup function to properly stop and dispose of audio resources\n  const cleanupAudio = () => {\n    if (soundRef.current) {\n      try {\n        soundRef.current.stop();\n        soundRef.current.unload();\n      } catch (error) {\n        console.warn('Error during Howl cleanup:', error);\n      }\n      soundRef.current = null;\n    }\n    \n    if (testAudioRef.current) {\n      try {\n        testAudioRef.current.pause();\n        testAudioRef.current.src = '';\n        testAudioRef.current.load();\n      } catch (error) {\n        console.warn('Error during HTML5 audio cleanup:', error);\n      }\n      testAudioRef.current = null;\n    }\n    \n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  };\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanupAudio();\n    };\n  }, []);\n\n    // Test if track URL is accessible\n  const testTrackAccessibility = async (url) => {\n    try {\n      console.log('ðŸ” Testing track accessibility:', url);\n      const response = await fetch(url, { \n        method: 'HEAD',\n        mode: 'cors'\n      });\n      console.log('âœ… Track accessibility test result:', response.status, response.statusText);\n      return response.ok;\n    } catch (error) {\n      console.error('âŒ Track accessibility test failed:', error);\n      return false;\n    }\n  };\n\n  // Keep a session-level set of tracks already incremented to avoid double counting on resume\n  const incrementedRef = useRef(new Set());\n  const lastIncrementTrackIdRef = useRef(null);\n\n  // Increment play count for a track (single fire per track start) using new endpoint\n  const incrementPlayCount = async (track) => {\n    if (!track?.id) return;\n    const id = track.id;\n    // Avoid duplicate increments if already incremented during this play session\n    if (lastIncrementTrackIdRef.current === id) return;\n    lastIncrementTrackIdRef.current = id;\n    try {\n      const res = await fetch(`/api/tracks/${id}/play`, { method: 'POST' });\n      if (res.ok) {\n        const data = await res.json();\n        const updatedTrack = data.track;\n        // Optimistically update currentTrack and queue copy\n        setCurrentTrack(prev => prev && prev.id === id ? { ...prev, play_count: updatedTrack.play_count } : prev);\n        setQueue(prev => prev.map(t => t.id === id ? { ...t, play_count: updatedTrack.play_count } : t));\n      }\n    } catch (err) {\n      console.warn('Failed to increment play count', err);\n    }\n  };\n\n  const playTrack = async (track, trackListArg) => {\n    console.log('=== PLAYER DEBUG ===');\n    console.log('Attempting to play track:', track);\n    console.log('Track file_url:', track.file_url);\n    console.log('Track hls_url:', track.hls_url);\n    \n    // Clean up any existing audio resources first\n    cleanupAudio();\n    setError(null); // Clear any previous errors\n\n    setIsLoading(true);\n    setCurrentTrack(track);\n    // Use provided trackListArg as queue if available, else use current queue\n    const queueToUse = Array.isArray(trackListArg) && trackListArg.length > 0 ? trackListArg : queue;\n    setQueue(queueToUse);\n    setCurrentIndex(queueToUse.findIndex(t => t.id === track.id));\n\n    const audioUrl = track.hls_url || track.file_url;\n    console.log('Using audio URL:', audioUrl);\n\n    // Validate URL\n    if (!audioUrl) {\n      setError('No audio URL available for this track');\n      setIsLoading(false);\n      return;\n    }\n\n    // Test track accessibility before attempting to play\n    const isAccessible = await testTrackAccessibility(audioUrl);\n    if (!isAccessible) {\n      console.error('âŒ Track is not accessible');\n      setError('Cannot access audio file. The track may be missing or the server is unavailable.');\n      setIsLoading(false);\n      return;\n    }\n\n    console.log('âœ… Track is accessible, proceeding with audio setup...');\n\n    // Test direct HTML5 audio first for debugging\n    testAudioRef.current = new Audio();\n    testAudioRef.current.crossOrigin = 'anonymous';\n    testAudioRef.current.preload = 'metadata';\n    \n    testAudioRef.current.addEventListener('canplay', () => {\n      console.log('âœ… HTML5 Audio can play this file');\n    });\n    \n    testAudioRef.current.addEventListener('loadedmetadata', () => {\n      console.log('âœ… HTML5 Audio metadata loaded, duration:', testAudioRef.current.duration);\n    });\n    \n    testAudioRef.current.addEventListener('error', (e) => {\n      console.error('âŒ HTML5 Audio error:', e);\n      console.error('Audio error code:', testAudioRef.current?.error?.code);\n      console.error('Audio error message:', testAudioRef.current?.error?.message);\n      \n      // Error codes: 1=ABORTED, 2=NETWORK, 3=DECODE, 4=SRC_NOT_SUPPORTED\n      const errorMessages = {\n        1: 'Audio loading was aborted',\n        2: 'Network error while loading audio',\n        3: 'Audio decoding failed',\n        4: 'Audio format not supported'\n      };\n      \n      const errorCode = testAudioRef.current?.error?.code;\n      const errorMsg = errorMessages[errorCode] || 'Unknown audio error';\n      console.error('Detailed error:', errorMsg);\n    });\n    \n    // Set source and load\n    testAudioRef.current.src = audioUrl;\n    testAudioRef.current.load();\n\n    // Create new Howl instance with better error handling\n    soundRef.current = new Howl({\n      src: [audioUrl],\n      html5: true, // Use HTML5 Audio for better compatibility\n      format: ['mp3', 'wav', 'mpeg'], // Support multiple formats\n      volume: volume,\n      preload: true,\n      cors: true, // Enable CORS\n      onload: () => {\n        console.log('âœ… Howler: Audio loaded successfully');\n        console.log('Duration:', soundRef.current.duration());\n        setDuration(soundRef.current.duration());\n        setIsLoading(false);\n        setError(null);\n      },\n      onplay: () => {\n        console.log('âœ… Howler: Audio started playing');\n        setIsPlaying(true);\n        setIsLoading(false);\n        setError(null);\n        startTimeTracking();\n        if (track && track.id) {\n          incrementPlayCount(track);\n        }\n      },\n      onpause: () => {\n        console.log('â¸ï¸ Howler: Audio paused');\n        setIsPlaying(false);\n        clearInterval(intervalRef.current);\n      },\n      onend: () => {\n        console.log('ðŸ”š Howler: Audio ended');\n        setIsPlaying(false);\n        setCurrentTime(0);\n        clearInterval(intervalRef.current);\n        handleTrackEnd();\n      },\n      onloaderror: (id, error) => {\n        console.error('âŒ Howler: Audio load error:', error);\n        console.error('âŒ Howler: Error ID:', id);\n        console.error('âŒ Howler: Full error object:', error);\n        \n        // More specific error messages\n        let errorMsg = 'Failed to load audio file.';\n        if (typeof error === 'string' && error.includes('404')) {\n          errorMsg = 'Audio file not found (404). The track may have been moved or deleted.';\n        } else if (typeof error === 'string' && error.includes('CORS')) {\n          errorMsg = 'Cross-origin request blocked. Please contact support.';\n        } else if (typeof error === 'string' && error.includes('network')) {\n          errorMsg = 'Network error. Please check your connection and try again.';\n        }\n        \n        setError(errorMsg);\n        setIsLoading(false);\n        setIsPlaying(false);\n      },\n      onplayerror: (id, error) => {\n        console.error('âŒ Howler: Audio play error:', error);\n        console.error('âŒ Howler: Error ID:', id);\n        \n        let errorMsg = 'Failed to play audio.';\n        if (typeof error === 'string' && error.includes('NotAllowedError')) {\n          errorMsg = 'Playback blocked by browser. Please click play again to allow audio.';\n        } else if (typeof error === 'string' && error.includes('decode')) {\n          errorMsg = 'Audio file is corrupted or in an unsupported format.';\n        }\n        \n        setError(errorMsg);\n        setIsLoading(false);\n        setIsPlaying(false);\n      },\n      onerror: (error) => {\n        console.error('âŒ Howler: General audio error:', error);\n        setError('An audio error occurred. Please try refreshing the page.');\n        setIsLoading(false);\n        setIsPlaying(false);\n      },\n    });\n\n    console.log('ðŸ”„ Howler instance created, attempting to play...');\n    try {\n      // Add a small delay to ensure the audio is properly loaded\n      setTimeout(() => {\n        if (soundRef.current && soundRef.current.state() === 'loaded') {\n          const playResult = soundRef.current.play();\n          console.log('Play result:', playResult);\n        }\n      }, 100);\n    } catch (error) {\n      console.error('âŒ Play attempt failed:', error);\n      setError('Failed to start playback. Please try again.');\n      setIsLoading(false);\n      setIsPlaying(false);\n    }\n  };\n\n  const handleTrackEnd = () => {\n    try {\n      if (repeatMode === 'one') {\n        // Replay current track\n        if (soundRef.current && soundRef.current.state() === 'loaded') {\n          soundRef.current.seek(0);\n          soundRef.current.play();\n        }\n      } else if (repeatMode === 'all' || queue.length > currentIndex + 1) {\n        playNext();\n      }\n    } catch (error) {\n      console.error('âŒ Error in handleTrackEnd:', error);\n      setIsPlaying(false);\n    }\n  };\n\n  const startTimeTracking = () => {\n    intervalRef.current = setInterval(() => {\n      if (soundRef.current && soundRef.current.playing()) {\n        setCurrentTime(soundRef.current.seek());\n      }\n    }, 1000);\n  };\n\n  const togglePlayPause = () => {\n    if (soundRef.current && soundRef.current.state() === 'loaded') {\n      try {\n        if (isPlaying) {\n          soundRef.current.pause();\n        } else {\n          // Check if the sound is still valid before playing\n          if (soundRef.current._src) {\n            const playPromise = soundRef.current.play();\n            if (playPromise !== undefined) {\n              // Handle the promise if returned\n              console.log('Play initiated successfully');\n            }\n          }\n        }\n      } catch (error) {\n        console.error('âŒ Error in togglePlayPause:', error);\n        setIsPlaying(false);\n        setIsLoading(false);\n      }\n    }\n  };\n\n  const seek = (time) => {\n    if (soundRef.current) {\n      soundRef.current.seek(time);\n      setCurrentTime(time);\n    }\n  };\n\n  const changeVolume = (newVolume) => {\n    setVolume(newVolume);\n    if (soundRef.current) {\n      soundRef.current.volume(newVolume);\n    }\n  };\n\n  const playNext = () => {\n    if (queue.length > 0) {\n      let nextIndex;\n      \n      if (shuffleMode) {\n        // Random next track\n        nextIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex < queue.length - 1) {\n        nextIndex = currentIndex + 1;\n      } else if (repeatMode === 'all') {\n        nextIndex = 0; // Loop back to start\n      } else {\n        return; // No next track\n      }\n      \n      const nextTrack = queue[nextIndex];\n      playTrack(nextTrack, queue);\n    }\n  };\n\n  const playPrevious = () => {\n    if (queue.length > 0) {\n      let prevIndex;\n      \n      if (shuffleMode) {\n        // Random previous track\n        prevIndex = Math.floor(Math.random() * queue.length);\n      } else if (currentIndex > 0) {\n        prevIndex = currentIndex - 1;\n      } else if (repeatMode === 'all') {\n        prevIndex = queue.length - 1; // Loop to end\n      } else {\n        return; // No previous track\n      }\n      \n      const prevTrack = queue[prevIndex];\n      playTrack(prevTrack, queue);\n    }\n  };\n\n  const toggleShuffle = () => {\n    setShuffleMode(!shuffleMode);\n  };\n\n  const setRepeat = (mode) => {\n    setRepeatMode(mode);\n  };\n\n  const addToQueue = (track) => {\n    setQueue(prev => [...prev, track]);\n  };\n\n  const removeFromQueue = (trackId) => {\n    setQueue(prev => prev.filter(track => track.id !== trackId));\n  };\n\n  const clearQueue = () => {\n    setQueue([]);\n    setCurrentIndex(0);\n  };\n\n  const stop = () => {\n    cleanupAudio();\n    setCurrentTrack(null);\n    setIsPlaying(false);\n    setCurrentTime(0);\n    setIsLoading(false);\n  };\n\n  const value = {\n    currentTrack,\n    isPlaying,\n    volume,\n    currentTime,\n    duration,\n    queue,\n    currentIndex,\n    shuffleMode,\n    repeatMode,\n    isLoading,\n    error,\n    playTrack,\n    togglePlayPause,\n    stop,\n    seek,\n    changeVolume,\n    playNext,\n    playPrevious,\n    addToQueue,\n    removeFromQueue,\n    clearQueue,\n    toggleShuffle,\n    setRepeat\n  };\n\n  return (\n    <PlayerContext.Provider value={value}>\n      {children}\n    </PlayerContext.Provider>\n  );\n};\n"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,SAAS,QAAQ,OAAO;AACrF,SAASC,IAAI,QAAQ,QAAQ;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE9B,MAAMC,aAAa,gBAAGR,aAAa,CAAC,CAAC;AAErC,OAAO,MAAMS,SAAS,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC7B,MAAMC,OAAO,GAAGV,UAAU,CAACO,aAAa,CAAC;EACzC,IAAI,CAACG,OAAO,EAAE;IACZ,MAAM,IAAIC,KAAK,CAAC,gDAAgD,CAAC;EACnE;EACA,OAAOD,OAAO;AAChB,CAAC;AAACD,EAAA,CANWD,SAAS;AAQtB,OAAO,MAAMI,cAAc,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,GAAA;EAC9C,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGf,QAAQ,CAAC,IAAI,CAAC;EACtD,MAAM,CAACgB,SAAS,EAAEC,YAAY,CAAC,GAAGjB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACkB,MAAM,EAAEC,SAAS,CAAC,GAAGnB,QAAQ,CAAC,GAAG,CAAC;EACzC,MAAM,CAACoB,WAAW,EAAEC,cAAc,CAAC,GAAGrB,QAAQ,CAAC,CAAC,CAAC;EACjD,MAAM,CAACsB,QAAQ,EAAEC,WAAW,CAAC,GAAGvB,QAAQ,CAAC,CAAC,CAAC;EAC3C,MAAM,CAACwB,KAAK,EAAEC,QAAQ,CAAC,GAAGzB,QAAQ,CAAC,EAAE,CAAC;EACtC,MAAM,CAAC0B,YAAY,EAAEC,eAAe,CAAC,GAAG3B,QAAQ,CAAC,CAAC,CAAC;EACnD,MAAM,CAAC4B,WAAW,EAAEC,cAAc,CAAC,GAAG7B,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAAC8B,UAAU,EAAEC,aAAa,CAAC,GAAG/B,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;EACrD,MAAM,CAACgC,SAAS,EAAEC,YAAY,CAAC,GAAGjC,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACkC,KAAK,EAAEC,QAAQ,CAAC,GAAGnC,QAAQ,CAAC,IAAI,CAAC;EAExC,MAAMoC,QAAQ,GAAGnC,MAAM,CAAC,IAAI,CAAC;EAC7B,MAAMoC,WAAW,GAAGpC,MAAM,CAAC,IAAI,CAAC;EAChC,MAAMqC,YAAY,GAAGrC,MAAM,CAAC,IAAI,CAAC;;EAEjC;EACA,MAAMsC,YAAY,GAAGA,CAAA,KAAM;IACzB,IAAIH,QAAQ,CAACI,OAAO,EAAE;MACpB,IAAI;QACFJ,QAAQ,CAACI,OAAO,CAACC,IAAI,CAAC,CAAC;QACvBL,QAAQ,CAACI,OAAO,CAACE,MAAM,CAAC,CAAC;MAC3B,CAAC,CAAC,OAAOR,KAAK,EAAE;QACdS,OAAO,CAACC,IAAI,CAAC,4BAA4B,EAAEV,KAAK,CAAC;MACnD;MACAE,QAAQ,CAACI,OAAO,GAAG,IAAI;IACzB;IAEA,IAAIF,YAAY,CAACE,OAAO,EAAE;MACxB,IAAI;QACFF,YAAY,CAACE,OAAO,CAACK,KAAK,CAAC,CAAC;QAC5BP,YAAY,CAACE,OAAO,CAACM,GAAG,GAAG,EAAE;QAC7BR,YAAY,CAACE,OAAO,CAACO,IAAI,CAAC,CAAC;MAC7B,CAAC,CAAC,OAAOb,KAAK,EAAE;QACdS,OAAO,CAACC,IAAI,CAAC,mCAAmC,EAAEV,KAAK,CAAC;MAC1D;MACAI,YAAY,CAACE,OAAO,GAAG,IAAI;IAC7B;IAEA,IAAIH,WAAW,CAACG,OAAO,EAAE;MACvBQ,aAAa,CAACX,WAAW,CAACG,OAAO,CAAC;MAClCH,WAAW,CAACG,OAAO,GAAG,IAAI;IAC5B;EACF,CAAC;;EAED;EACAtC,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACXqC,YAAY,CAAC,CAAC;IAChB,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEJ;EACF,MAAMU,sBAAsB,GAAG,MAAOC,GAAG,IAAK;IAC5C,IAAI;MACFP,OAAO,CAACQ,GAAG,CAAC,iCAAiC,EAAED,GAAG,CAAC;MACnD,MAAME,QAAQ,GAAG,MAAMC,KAAK,CAACH,GAAG,EAAE;QAChCI,MAAM,EAAE,MAAM;QACdC,IAAI,EAAE;MACR,CAAC,CAAC;MACFZ,OAAO,CAACQ,GAAG,CAAC,oCAAoC,EAAEC,QAAQ,CAACI,MAAM,EAAEJ,QAAQ,CAACK,UAAU,CAAC;MACvF,OAAOL,QAAQ,CAACM,EAAE;IACpB,CAAC,CAAC,OAAOxB,KAAK,EAAE;MACdS,OAAO,CAACT,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;MAC1D,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMyB,cAAc,GAAG1D,MAAM,CAAC,IAAI2D,GAAG,CAAC,CAAC,CAAC;EACxC,MAAMC,uBAAuB,GAAG5D,MAAM,CAAC,IAAI,CAAC;;EAE5C;EACA,MAAM6D,kBAAkB,GAAG,MAAOC,KAAK,IAAK;IAC1C,IAAI,EAACA,KAAK,aAALA,KAAK,eAALA,KAAK,CAAEC,EAAE,GAAE;IAChB,MAAMA,EAAE,GAAGD,KAAK,CAACC,EAAE;IACnB;IACA,IAAIH,uBAAuB,CAACrB,OAAO,KAAKwB,EAAE,EAAE;IAC5CH,uBAAuB,CAACrB,OAAO,GAAGwB,EAAE;IACpC,IAAI;MACF,MAAMC,GAAG,GAAG,MAAMZ,KAAK,CAAC,eAAeW,EAAE,OAAO,EAAE;QAAEV,MAAM,EAAE;MAAO,CAAC,CAAC;MACrE,IAAIW,GAAG,CAACP,EAAE,EAAE;QACV,MAAMQ,IAAI,GAAG,MAAMD,GAAG,CAACE,IAAI,CAAC,CAAC;QAC7B,MAAMC,YAAY,GAAGF,IAAI,CAACH,KAAK;QAC/B;QACAhD,eAAe,CAACsD,IAAI,IAAIA,IAAI,IAAIA,IAAI,CAACL,EAAE,KAAKA,EAAE,GAAG;UAAE,GAAGK,IAAI;UAAEC,UAAU,EAAEF,YAAY,CAACE;QAAW,CAAC,GAAGD,IAAI,CAAC;QACzG5C,QAAQ,CAAC4C,IAAI,IAAIA,IAAI,CAACE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACR,EAAE,KAAKA,EAAE,GAAG;UAAE,GAAGQ,CAAC;UAAEF,UAAU,EAAEF,YAAY,CAACE;QAAW,CAAC,GAAGE,CAAC,CAAC,CAAC;MAClG;IACF,CAAC,CAAC,OAAOC,GAAG,EAAE;MACZ9B,OAAO,CAACC,IAAI,CAAC,gCAAgC,EAAE6B,GAAG,CAAC;IACrD;EACF,CAAC;EAED,MAAMC,SAAS,GAAG,MAAAA,CAAOX,KAAK,EAAEY,YAAY,KAAK;IAC/ChC,OAAO,CAACQ,GAAG,CAAC,sBAAsB,CAAC;IACnCR,OAAO,CAACQ,GAAG,CAAC,2BAA2B,EAAEY,KAAK,CAAC;IAC/CpB,OAAO,CAACQ,GAAG,CAAC,iBAAiB,EAAEY,KAAK,CAACa,QAAQ,CAAC;IAC9CjC,OAAO,CAACQ,GAAG,CAAC,gBAAgB,EAAEY,KAAK,CAACc,OAAO,CAAC;;IAE5C;IACAtC,YAAY,CAAC,CAAC;IACdJ,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;;IAEhBF,YAAY,CAAC,IAAI,CAAC;IAClBlB,eAAe,CAACgD,KAAK,CAAC;IACtB;IACA,MAAMe,UAAU,GAAGC,KAAK,CAACC,OAAO,CAACL,YAAY,CAAC,IAAIA,YAAY,CAACM,MAAM,GAAG,CAAC,GAAGN,YAAY,GAAGnD,KAAK;IAChGC,QAAQ,CAACqD,UAAU,CAAC;IACpBnD,eAAe,CAACmD,UAAU,CAACI,SAAS,CAACV,CAAC,IAAIA,CAAC,CAACR,EAAE,KAAKD,KAAK,CAACC,EAAE,CAAC,CAAC;IAE7D,MAAMmB,QAAQ,GAAGpB,KAAK,CAACc,OAAO,IAAId,KAAK,CAACa,QAAQ;IAChDjC,OAAO,CAACQ,GAAG,CAAC,kBAAkB,EAAEgC,QAAQ,CAAC;;IAEzC;IACA,IAAI,CAACA,QAAQ,EAAE;MACbhD,QAAQ,CAAC,uCAAuC,CAAC;MACjDF,YAAY,CAAC,KAAK,CAAC;MACnB;IACF;;IAEA;IACA,MAAMmD,YAAY,GAAG,MAAMnC,sBAAsB,CAACkC,QAAQ,CAAC;IAC3D,IAAI,CAACC,YAAY,EAAE;MACjBzC,OAAO,CAACT,KAAK,CAAC,2BAA2B,CAAC;MAC1CC,QAAQ,CAAC,kFAAkF,CAAC;MAC5FF,YAAY,CAAC,KAAK,CAAC;MACnB;IACF;IAEAU,OAAO,CAACQ,GAAG,CAAC,uDAAuD,CAAC;;IAEpE;IACAb,YAAY,CAACE,OAAO,GAAG,IAAI6C,KAAK,CAAC,CAAC;IAClC/C,YAAY,CAACE,OAAO,CAAC8C,WAAW,GAAG,WAAW;IAC9ChD,YAAY,CAACE,OAAO,CAAC+C,OAAO,GAAG,UAAU;IAEzCjD,YAAY,CAACE,OAAO,CAACgD,gBAAgB,CAAC,SAAS,EAAE,MAAM;MACrD7C,OAAO,CAACQ,GAAG,CAAC,kCAAkC,CAAC;IACjD,CAAC,CAAC;IAEFb,YAAY,CAACE,OAAO,CAACgD,gBAAgB,CAAC,gBAAgB,EAAE,MAAM;MAC5D7C,OAAO,CAACQ,GAAG,CAAC,0CAA0C,EAAEb,YAAY,CAACE,OAAO,CAAClB,QAAQ,CAAC;IACxF,CAAC,CAAC;IAEFgB,YAAY,CAACE,OAAO,CAACgD,gBAAgB,CAAC,OAAO,EAAGC,CAAC,IAAK;MAAA,IAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA;MACpDpD,OAAO,CAACT,KAAK,CAAC,sBAAsB,EAAEuD,CAAC,CAAC;MACxC9C,OAAO,CAACT,KAAK,CAAC,mBAAmB,GAAAwD,qBAAA,GAAEpD,YAAY,CAACE,OAAO,cAAAkD,qBAAA,wBAAAC,sBAAA,GAApBD,qBAAA,CAAsBxD,KAAK,cAAAyD,sBAAA,uBAA3BA,sBAAA,CAA6BK,IAAI,CAAC;MACrErD,OAAO,CAACT,KAAK,CAAC,sBAAsB,GAAA0D,sBAAA,GAAEtD,YAAY,CAACE,OAAO,cAAAoD,sBAAA,wBAAAC,sBAAA,GAApBD,sBAAA,CAAsB1D,KAAK,cAAA2D,sBAAA,uBAA3BA,sBAAA,CAA6BI,OAAO,CAAC;;MAE3E;MACA,MAAMC,aAAa,GAAG;QACpB,CAAC,EAAE,2BAA2B;QAC9B,CAAC,EAAE,mCAAmC;QACtC,CAAC,EAAE,uBAAuB;QAC1B,CAAC,EAAE;MACL,CAAC;MAED,MAAMC,SAAS,IAAAL,sBAAA,GAAGxD,YAAY,CAACE,OAAO,cAAAsD,sBAAA,wBAAAC,sBAAA,GAApBD,sBAAA,CAAsB5D,KAAK,cAAA6D,sBAAA,uBAA3BA,sBAAA,CAA6BC,IAAI;MACnD,MAAMI,QAAQ,GAAGF,aAAa,CAACC,SAAS,CAAC,IAAI,qBAAqB;MAClExD,OAAO,CAACT,KAAK,CAAC,iBAAiB,EAAEkE,QAAQ,CAAC;IAC5C,CAAC,CAAC;;IAEF;IACA9D,YAAY,CAACE,OAAO,CAACM,GAAG,GAAGqC,QAAQ;IACnC7C,YAAY,CAACE,OAAO,CAACO,IAAI,CAAC,CAAC;;IAE3B;IACAX,QAAQ,CAACI,OAAO,GAAG,IAAIrC,IAAI,CAAC;MAC1B2C,GAAG,EAAE,CAACqC,QAAQ,CAAC;MACfkB,KAAK,EAAE,IAAI;MAAE;MACbC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC;MAAE;MAChCpF,MAAM,EAAEA,MAAM;MACdqE,OAAO,EAAE,IAAI;MACbgB,IAAI,EAAE,IAAI;MAAE;MACZC,MAAM,EAAEA,CAAA,KAAM;QACZ7D,OAAO,CAACQ,GAAG,CAAC,qCAAqC,CAAC;QAClDR,OAAO,CAACQ,GAAG,CAAC,WAAW,EAAEf,QAAQ,CAACI,OAAO,CAAClB,QAAQ,CAAC,CAAC,CAAC;QACrDC,WAAW,CAACa,QAAQ,CAACI,OAAO,CAAClB,QAAQ,CAAC,CAAC,CAAC;QACxCW,YAAY,CAAC,KAAK,CAAC;QACnBE,QAAQ,CAAC,IAAI,CAAC;MAChB,CAAC;MACDsE,MAAM,EAAEA,CAAA,KAAM;QACZ9D,OAAO,CAACQ,GAAG,CAAC,iCAAiC,CAAC;QAC9ClC,YAAY,CAAC,IAAI,CAAC;QAClBgB,YAAY,CAAC,KAAK,CAAC;QACnBE,QAAQ,CAAC,IAAI,CAAC;QACduE,iBAAiB,CAAC,CAAC;QACnB,IAAI3C,KAAK,IAAIA,KAAK,CAACC,EAAE,EAAE;UACrBF,kBAAkB,CAACC,KAAK,CAAC;QAC3B;MACF,CAAC;MACD4C,OAAO,EAAEA,CAAA,KAAM;QACbhE,OAAO,CAACQ,GAAG,CAAC,yBAAyB,CAAC;QACtClC,YAAY,CAAC,KAAK,CAAC;QACnB+B,aAAa,CAACX,WAAW,CAACG,OAAO,CAAC;MACpC,CAAC;MACDoE,KAAK,EAAEA,CAAA,KAAM;QACXjE,OAAO,CAACQ,GAAG,CAAC,wBAAwB,CAAC;QACrClC,YAAY,CAAC,KAAK,CAAC;QACnBI,cAAc,CAAC,CAAC,CAAC;QACjB2B,aAAa,CAACX,WAAW,CAACG,OAAO,CAAC;QAClCqE,cAAc,CAAC,CAAC;MAClB,CAAC;MACDC,WAAW,EAAEA,CAAC9C,EAAE,EAAE9B,KAAK,KAAK;QAC1BS,OAAO,CAACT,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;QACnDS,OAAO,CAACT,KAAK,CAAC,qBAAqB,EAAE8B,EAAE,CAAC;QACxCrB,OAAO,CAACT,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;;QAEpD;QACA,IAAIkE,QAAQ,GAAG,4BAA4B;QAC3C,IAAI,OAAOlE,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC6E,QAAQ,CAAC,KAAK,CAAC,EAAE;UACtDX,QAAQ,GAAG,uEAAuE;QACpF,CAAC,MAAM,IAAI,OAAOlE,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC6E,QAAQ,CAAC,MAAM,CAAC,EAAE;UAC9DX,QAAQ,GAAG,uDAAuD;QACpE,CAAC,MAAM,IAAI,OAAOlE,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC6E,QAAQ,CAAC,SAAS,CAAC,EAAE;UACjEX,QAAQ,GAAG,4DAA4D;QACzE;QAEAjE,QAAQ,CAACiE,QAAQ,CAAC;QAClBnE,YAAY,CAAC,KAAK,CAAC;QACnBhB,YAAY,CAAC,KAAK,CAAC;MACrB,CAAC;MACD+F,WAAW,EAAEA,CAAChD,EAAE,EAAE9B,KAAK,KAAK;QAC1BS,OAAO,CAACT,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;QACnDS,OAAO,CAACT,KAAK,CAAC,qBAAqB,EAAE8B,EAAE,CAAC;QAExC,IAAIoC,QAAQ,GAAG,uBAAuB;QACtC,IAAI,OAAOlE,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC6E,QAAQ,CAAC,iBAAiB,CAAC,EAAE;UAClEX,QAAQ,GAAG,sEAAsE;QACnF,CAAC,MAAM,IAAI,OAAOlE,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC6E,QAAQ,CAAC,QAAQ,CAAC,EAAE;UAChEX,QAAQ,GAAG,sDAAsD;QACnE;QAEAjE,QAAQ,CAACiE,QAAQ,CAAC;QAClBnE,YAAY,CAAC,KAAK,CAAC;QACnBhB,YAAY,CAAC,KAAK,CAAC;MACrB,CAAC;MACDgG,OAAO,EAAG/E,KAAK,IAAK;QAClBS,OAAO,CAACT,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;QACtDC,QAAQ,CAAC,0DAA0D,CAAC;QACpEF,YAAY,CAAC,KAAK,CAAC;QACnBhB,YAAY,CAAC,KAAK,CAAC;MACrB;IACF,CAAC,CAAC;IAEF0B,OAAO,CAACQ,GAAG,CAAC,mDAAmD,CAAC;IAChE,IAAI;MACF;MACA+D,UAAU,CAAC,MAAM;QACf,IAAI9E,QAAQ,CAACI,OAAO,IAAIJ,QAAQ,CAACI,OAAO,CAAC2E,KAAK,CAAC,CAAC,KAAK,QAAQ,EAAE;UAC7D,MAAMC,UAAU,GAAGhF,QAAQ,CAACI,OAAO,CAAC6E,IAAI,CAAC,CAAC;UAC1C1E,OAAO,CAACQ,GAAG,CAAC,cAAc,EAAEiE,UAAU,CAAC;QACzC;MACF,CAAC,EAAE,GAAG,CAAC;IACT,CAAC,CAAC,OAAOlF,KAAK,EAAE;MACdS,OAAO,CAACT,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9CC,QAAQ,CAAC,6CAA6C,CAAC;MACvDF,YAAY,CAAC,KAAK,CAAC;MACnBhB,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC;EAED,MAAM4F,cAAc,GAAGA,CAAA,KAAM;IAC3B,IAAI;MACF,IAAI/E,UAAU,KAAK,KAAK,EAAE;QACxB;QACA,IAAIM,QAAQ,CAACI,OAAO,IAAIJ,QAAQ,CAACI,OAAO,CAAC2E,KAAK,CAAC,CAAC,KAAK,QAAQ,EAAE;UAC7D/E,QAAQ,CAACI,OAAO,CAAC8E,IAAI,CAAC,CAAC,CAAC;UACxBlF,QAAQ,CAACI,OAAO,CAAC6E,IAAI,CAAC,CAAC;QACzB;MACF,CAAC,MAAM,IAAIvF,UAAU,KAAK,KAAK,IAAIN,KAAK,CAACyD,MAAM,GAAGvD,YAAY,GAAG,CAAC,EAAE;QAClE6F,QAAQ,CAAC,CAAC;MACZ;IACF,CAAC,CAAC,OAAOrF,KAAK,EAAE;MACdS,OAAO,CAACT,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClDjB,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC;EAED,MAAMyF,iBAAiB,GAAGA,CAAA,KAAM;IAC9BrE,WAAW,CAACG,OAAO,GAAGgF,WAAW,CAAC,MAAM;MACtC,IAAIpF,QAAQ,CAACI,OAAO,IAAIJ,QAAQ,CAACI,OAAO,CAACiF,OAAO,CAAC,CAAC,EAAE;QAClDpG,cAAc,CAACe,QAAQ,CAACI,OAAO,CAAC8E,IAAI,CAAC,CAAC,CAAC;MACzC;IACF,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EAED,MAAMI,eAAe,GAAGA,CAAA,KAAM;IAC5B,IAAItF,QAAQ,CAACI,OAAO,IAAIJ,QAAQ,CAACI,OAAO,CAAC2E,KAAK,CAAC,CAAC,KAAK,QAAQ,EAAE;MAC7D,IAAI;QACF,IAAInG,SAAS,EAAE;UACboB,QAAQ,CAACI,OAAO,CAACK,KAAK,CAAC,CAAC;QAC1B,CAAC,MAAM;UACL;UACA,IAAIT,QAAQ,CAACI,OAAO,CAACmF,IAAI,EAAE;YACzB,MAAMC,WAAW,GAAGxF,QAAQ,CAACI,OAAO,CAAC6E,IAAI,CAAC,CAAC;YAC3C,IAAIO,WAAW,KAAKC,SAAS,EAAE;cAC7B;cACAlF,OAAO,CAACQ,GAAG,CAAC,6BAA6B,CAAC;YAC5C;UACF;QACF;MACF,CAAC,CAAC,OAAOjB,KAAK,EAAE;QACdS,OAAO,CAACT,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;QACnDjB,YAAY,CAAC,KAAK,CAAC;QACnBgB,YAAY,CAAC,KAAK,CAAC;MACrB;IACF;EACF,CAAC;EAED,MAAMqF,IAAI,GAAIQ,IAAI,IAAK;IACrB,IAAI1F,QAAQ,CAACI,OAAO,EAAE;MACpBJ,QAAQ,CAACI,OAAO,CAAC8E,IAAI,CAACQ,IAAI,CAAC;MAC3BzG,cAAc,CAACyG,IAAI,CAAC;IACtB;EACF,CAAC;EAED,MAAMC,YAAY,GAAIC,SAAS,IAAK;IAClC7G,SAAS,CAAC6G,SAAS,CAAC;IACpB,IAAI5F,QAAQ,CAACI,OAAO,EAAE;MACpBJ,QAAQ,CAACI,OAAO,CAACtB,MAAM,CAAC8G,SAAS,CAAC;IACpC;EACF,CAAC;EAED,MAAMT,QAAQ,GAAGA,CAAA,KAAM;IACrB,IAAI/F,KAAK,CAACyD,MAAM,GAAG,CAAC,EAAE;MACpB,IAAIgD,SAAS;MAEb,IAAIrG,WAAW,EAAE;QACf;QACAqG,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG5G,KAAK,CAACyD,MAAM,CAAC;MACtD,CAAC,MAAM,IAAIvD,YAAY,GAAGF,KAAK,CAACyD,MAAM,GAAG,CAAC,EAAE;QAC1CgD,SAAS,GAAGvG,YAAY,GAAG,CAAC;MAC9B,CAAC,MAAM,IAAII,UAAU,KAAK,KAAK,EAAE;QAC/BmG,SAAS,GAAG,CAAC,CAAC,CAAC;MACjB,CAAC,MAAM;QACL,OAAO,CAAC;MACV;MAEA,MAAMI,SAAS,GAAG7G,KAAK,CAACyG,SAAS,CAAC;MAClCvD,SAAS,CAAC2D,SAAS,EAAE7G,KAAK,CAAC;IAC7B;EACF,CAAC;EAED,MAAM8G,YAAY,GAAGA,CAAA,KAAM;IACzB,IAAI9G,KAAK,CAACyD,MAAM,GAAG,CAAC,EAAE;MACpB,IAAIsD,SAAS;MAEb,IAAI3G,WAAW,EAAE;QACf;QACA2G,SAAS,GAAGL,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG5G,KAAK,CAACyD,MAAM,CAAC;MACtD,CAAC,MAAM,IAAIvD,YAAY,GAAG,CAAC,EAAE;QAC3B6G,SAAS,GAAG7G,YAAY,GAAG,CAAC;MAC9B,CAAC,MAAM,IAAII,UAAU,KAAK,KAAK,EAAE;QAC/ByG,SAAS,GAAG/G,KAAK,CAACyD,MAAM,GAAG,CAAC,CAAC,CAAC;MAChC,CAAC,MAAM;QACL,OAAO,CAAC;MACV;MAEA,MAAMuD,SAAS,GAAGhH,KAAK,CAAC+G,SAAS,CAAC;MAClC7D,SAAS,CAAC8D,SAAS,EAAEhH,KAAK,CAAC;IAC7B;EACF,CAAC;EAED,MAAMiH,aAAa,GAAGA,CAAA,KAAM;IAC1B5G,cAAc,CAAC,CAACD,WAAW,CAAC;EAC9B,CAAC;EAED,MAAM8G,SAAS,GAAInF,IAAI,IAAK;IAC1BxB,aAAa,CAACwB,IAAI,CAAC;EACrB,CAAC;EAED,MAAMoF,UAAU,GAAI5E,KAAK,IAAK;IAC5BtC,QAAQ,CAAC4C,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAEN,KAAK,CAAC,CAAC;EACpC,CAAC;EAED,MAAM6E,eAAe,GAAIC,OAAO,IAAK;IACnCpH,QAAQ,CAAC4C,IAAI,IAAIA,IAAI,CAACyE,MAAM,CAAC/E,KAAK,IAAIA,KAAK,CAACC,EAAE,KAAK6E,OAAO,CAAC,CAAC;EAC9D,CAAC;EAED,MAAME,UAAU,GAAGA,CAAA,KAAM;IACvBtH,QAAQ,CAAC,EAAE,CAAC;IACZE,eAAe,CAAC,CAAC,CAAC;EACpB,CAAC;EAED,MAAMc,IAAI,GAAGA,CAAA,KAAM;IACjBF,YAAY,CAAC,CAAC;IACdxB,eAAe,CAAC,IAAI,CAAC;IACrBE,YAAY,CAAC,KAAK,CAAC;IACnBI,cAAc,CAAC,CAAC,CAAC;IACjBY,YAAY,CAAC,KAAK,CAAC;EACrB,CAAC;EAED,MAAM+G,KAAK,GAAG;IACZlI,YAAY;IACZE,SAAS;IACTE,MAAM;IACNE,WAAW;IACXE,QAAQ;IACRE,KAAK;IACLE,YAAY;IACZE,WAAW;IACXE,UAAU;IACVE,SAAS;IACTE,KAAK;IACLwC,SAAS;IACTgD,eAAe;IACfjF,IAAI;IACJ6E,IAAI;IACJS,YAAY;IACZR,QAAQ;IACRe,YAAY;IACZK,UAAU;IACVC,eAAe;IACfG,UAAU;IACVN,aAAa;IACbC;EACF,CAAC;EAED,oBACErI,OAAA,CAACC,aAAa,CAAC2I,QAAQ;IAACD,KAAK,EAAEA,KAAM;IAAApI,QAAA,EAClCA;EAAQ;IAAAsI,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACa,CAAC;AAE7B,CAAC;AAACxI,GAAA,CAzaWF,cAAc;AAAA2I,EAAA,GAAd3I,cAAc;AAAA,IAAA2I,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}